# Day 03：指针、引用和文件操作

## 课后习题

以下仅列出习题的要求，具体的程序实现、分析过程及运行结果请参阅每个习题对应的文件夹。

### Q1：函数指针练习

- 请编写一个函数 `add`，该函数接收两个 `int` 型参数，计算两数之和并打印，函数返回值为两数之和，再定义一个函数指针 `pf`，并将 `add` 赋予指针 `pf`。
- 通过函数指针的两种调用方式实现目标函数的调用。
- 请使用 `printf` 函数按照 `%p` 的格式，打印 `add`，`*add`，`&add`，`pf`，`*pf`，`&pf` 的值并比较打印出来的值。

### Q2：指针和数组练习

- 请定义一个`int`型的大小为`10`的一维数组`arr`，使用`printf`函数按照`%p` 格式打印`arr`、`&arr`和`&arr[0]`的值并比较。
- 请定义一个`int`型的大小为 10 的一维数组`buf`，再定义一个对应类型的指针变量`P`,比较`sizeof（buf）`和`sizeof（p）`的区别。
- 请定义一个`int`型的二维数组`data[3][4]`并初始化，再定义一个相应类型的指针变量`p`，并把`data`赋值给指针变量`p`。

### Q3：理解语法

- 请尝试理解语句：

```c
(*((void(*)())0))()
```

### Q4：指针和动态分配内存练习

- 尝试定义一个单向链表节点结构体`ListNode`，结构体包含两个字段，一个是`int`型的节点值`val`，一个是指向下个节点的指针`ListNode*`。
- 尝试利用上述节点实现一个包含`5`个节点的单链表，并遍历整个链表打印每个节点的值。

### Q5：文件基本操作练习

- 请手动创建一个文件 text，并使用标准 C 文件操作函数打开文件并写入自己的名字到文件，然后再打开文件，读取文件内容打印到控制台。

### Q6：使用指针动态分配内存并返回数组最大值

- 编写一个程序，使用指针动态分配一组内存，存储整数类型，并且返回数组的最大整数，最后需要释放内存。

### Q7：存储学生类的信息到文件中

- 定义一个学生类（包括姓名、分数、专业等）并且把学生信息存储到文件当中。

## 今日授课重点

### 常量指针与指针常量

常量指针（`const int *p`）指向的数据是常量，不能通过该指针修改数据，但指针本身可以指向不同的地址。例如：

```c++
const int *p = &x; // p指向x，x不能通过p修改
```

指针常量（int \* const p）是指针本身是常量，无法更改指向的地址，但可以通过该指针修改所指向的数据。例如：

```c++
int * const p = &x; // p不能指向其他地址，但可以修改x的值
```

### 数组指针与指针数组

数组指针（int (\*p)[5]）是一个指向数组的指针，指针本身可以指向不同的数组。例如：

```c++
int arr[5] = {1, 2, 3, 4, 5};
int (*p)[5] = &arr; // p指向数组arr
```

指针数组（int \*p[5]）是一个数组，数组的每个元素都是一个指针。例如：

```c++
int *p[5]; // p是一个含有5个指针的数组
```

### 函数指针与指针函数

函数指针（int (\*p)(int)）是一个指向函数的指针，可以通过它调用指定的函数。例如：

```c++
int add(int x)
{
    return x + 1;
}
int (*p)(int) = add; // p是指向add函数的指针
```

指针函数（int \*p()）是返回指针的函数，返回值是一个指向特定类型的指针。例如：

```c++
int* func() {
    static int x = 10;
    return &x;
}
```

## 预习 STL 内容

STL 是 C++ 标准库的一部分，提供了一组常用的模板，帮助高效处理数据。在数据结构与算法这门课中，我们就学习过 STL。

### 重要的 STL 容器

1. **vector**：

   - 动态数组，提供随机访问元素，支持快速的尾部插入和删除。

2. **list**：

   - 双向链表，支持在任意位置进行插入和删除操作，但访问速度较慢。

3. **deque**：

   - 双端队列，可以在两端进行插入和删除操作，性能较 vector 更好。

4. **set**：

   - 存储不重复元素的集合，元素按特定顺序自动排序。

5. **map**：
   - 键值对集合，支持根据键查找值。内部元素按键排序。

### 重要的 STL 算法

1. **sort**：

   - 对容器中的元素进行排序，默认按照升序排序。

2. **find**：

   - 查找容器中某个元素，返回该元素的迭代器，若未找到返回 `end`。

3. **reverse**：

   - 反转容器中的元素顺序。

4. **accumulate**：

   - 计算容器中元素的总和。

5. **copy**：
   - 复制容器中的元素到另一个容器或输出流。
